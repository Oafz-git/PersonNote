#	基础正则

* 作用：搜索文本

* 学习正则表达式本质就是学习各种各样的元字符并记住这些元字符的含义。

* 编程语言支持高级正则表达式
* 工具：grep/sed、awk、文本编辑器、IDE

##	搜索字符的三种方式

1. 精确搜索
2. 通配符搜索       `sql % _ [] [^]`
3. 正则表达式搜索 
   * 元字符：预定义号的具有特殊含义的符号，能够进行通配
   * 可读性非常的差
   * 写正则表达式并不难

# 正则分类

正则表达式的分类：

* 基础正则表达式（BRE：basic regular expression）
* 扩展正则表达式（ERE：extended regular expression）
* 编程语言支持的高级正则表达式

BRE和ERE语法基本一致，只有部分元字符（预定义好的带有特殊含义的一些符号）需要区别对待。

* 扩展正则中这些元字符可直接使用：`? + { } | ( )`
* 基础正则中这些元字符前需要加反斜线转义 `\?  \+  \{  \}  \|  \(  \)`
  * grep/sed 默认使用基础正则表达式
  * grep -E、sed -r、egrep、 awk扩展正则表达式

## 纯普通字符匹配

```shell
echo "hello world" | grep 'world'
```

## 基本的正则表达式元字符

### 匹配字符

***

- `abc` 匹配字符串“abc”，普通字符的匹配

- `[abcde...]` 匹配中括号内的任意单个字符

  > `a[xyz]b` axb ayb azb， 不能匹配aab amb

- `\n` 匹配换行符

- `\t` 匹配制表符

- `\w` 匹配单词字符

- `\W` 匹配非单词字符

- `\s` 匹配空白字符

- `\S` 匹配非空白字符

- `\d` 匹配数字

- `\D` 匹配非数字

- `.` 匹配任意单个字符

  > 默认情况下，`.`无法匹配换行符，可在多行模式下设置匹配模式修饰符使之真正匹配任意字符，包括换行符

***单词***：在正则表达式中的含义：`[a-zA-Z0-9]` 组成的字符或字符串都是单词，例如`nihao,hello world_`,第一个单词是`nihao`，第二个单词是`hello`，第三个单词是`world_`。

### 中括号表达式

***

#### 字符组

普通中括号包围的字符组：表示某单个字符匹配中括号内的任一字符即匹配成功

* `x[abc]z` ：可以匹配包含“xaz”、“xbz”、“xcz”的字符串

* 取反表示法：中括号内开头使用`^`, 表示只要不是中括号中的字符就匹配

  > `x[^abc]z` :可匹配包含“xdz”等字符串，但不能匹配包含“xaz”的字符串

* 范围表示法：

  > `[a-z]` ：代表任一单个小写字母
  >
  > `[^a-z]` ：只要单个非小写字母的其它任一字符
  >
  > `[A-Z]` ：代表任一单个大写字母
  >
  > `[0-9]` ：代表任一单个数字
  >
  > 注：`[0-59]` 表示匹配`0、1、2、3、4、5、9` 而不是0到59中间的数值
  >
  > `[a-z0-9A-Z]` ：代表任一字母或数字
  >
  > `[a-z0-9A-Z_]` ：代表任一字母、数字或下划线，即匹配**单词字符**（word）
  >
  > 注：`[A-z]或[a-Z]` ：建议不要使用这种横跨大小写字母的范围表达式，不同地方表达的含义不同；甚至有些按照字典顺序排序时，`[a-d]`不是等价于abcd，而是等价于aBbCcDd。如果想要等价于abcd，应将locale环境设置为C：`LC_ALL=C`

* 特殊元字符在中括号中的匹配：

  > 想要在中括号中匹配`^`，需将其放在中括号的非开头位置，如`[a^]`
  >
  > 想要在中括号中匹配`-`，需将其放在开头位置或结尾位置，如`[abc-]`、`[-abc]`
  >
  > 想要在中括号中匹配`]`，需将其放在开头位置，如`[]abc]`
  >
  > 想要匹配上面2个或3个元字符，`[]^]`、`[-^]`、`[]-]` `[]^-]`

#### 字符类

将字符分成不同的类别，称为字符类（character class）

下面是POSIX标准的字符类

| 字符类      | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| `[:lower:]` | 等价于`a-z`                                                  |
| `[:upper:]` | 等价于`A-Z`                                                  |
| `[:alpha:]` | 等价于`A-Za-z`，也等价于`[:lower:]+[:upper:]`                |
| `[:digit:]` | 等价于`0-9`                                                  |
| `[:alnum:]` | 等价于`0-9A-Za-z`，也等价于`[:lower:]+[:upper:]+[:digit:]`   |
| `[:xigit:]` | 匹配十六进制数字 `0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f` |
| `[:blank:]` | 匹配空格或制表符                                             |

#### 等价类和排序类（了解）

`[=x=]`包围时表示**等价类**，等价类表示将普通字母和带有重音的字母分为一类。例如aāáǎà是一类，它等价于[=a=]、oōóǒò又是一类，等价于[=o=]。注：没有[=ao=]这样连在一起的类。

例如：

```shell
echo "aāáǎà" | grep '[[=a=]]'
```

`[.xyz.]`包围时表示**排序类**，排序类表示将`[..]`包围中的多个符号当作一个字符，但要求在字符集中预先定义映射关系，例如已经预定义了xyz对应于R，那么`a[[.xyz.]]a`可以匹配`aRa`。

### 位置匹配（锚定）

***

字符匹配会消耗字符。位置匹配，只是匹配位置，不会消耗字符。

只匹配位置；不匹配字符，所以不会消耗字符数量，也称为即**零宽断言**。

* `^`匹配行首
* `$`匹配行尾
* `\<`匹配单词开头处的位置
* `\>`匹配单词结尾处的位置
* `\b`匹配单词边界处的位置（开头和结尾），所以`\bword\b`等价于`\<word>\`
* `\B`匹配非单词边界处的位置

### 量词（重复匹配次数）

***

* `{m}`表示匹配前一个字符或前一个子表达式m次
* `{m,n}`（m<n）表示匹配前一个字符或前一个子表达式最少m次，最多n次
