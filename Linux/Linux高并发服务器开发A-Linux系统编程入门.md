# Linux系统编程入门

## 一、Linux开发环境的搭建

ssh生成本机公钥和私钥`ssh-keygen -t rsa`

## 二、GCC介绍

### 01/什么是GCC

* GCC原名GNU C语言编译器（GNU C Compiler）
* GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言译器。
  * 包括C/C++/Objective-C/Java/Ada/Go前端，也包括这些语言的库（如libstdc++、libgcj等）
* GCC不仅支持C的许多‘方言’，也可以区分不同的C语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个C标准。例如，当使用命令行参数`-std=c99`启动GCC时，编译器支持C99标准
* 安装命令`sudo apt install gcc/g++`(版本>4.8.5,支持C++11)
* 查看版本`gcc/g++ -v/--version`

### 02/GCC工作流程

![GCC工作流程](https://oafz-draw-bed.oss-cn-beijing.aliyuncs.com/img/GCC工作流程.png)

### 03/gcc和g++的区别

* gcc和g++都是GNU（组织）的一个编译器
* **误区一：**gcc只能编译c代码，g++只能编译c++代码。两者都可以，注意：
  * 后缀为.c的，gcc把它当作是C程序，而g++当作是C++程序
  * 后缀为.cpp的，两者都会认为是C++程序，C++的语法规则更加严谨一些
  * 编译阶段，g++会调用gcc，对于C++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库链接，所以通常用g++来完成链接，为了统一，干脆编译/链接都用g++了，这就给人一种错觉，好像cpp程序只能用g++似的
* **误区二：**gcc不会定义`__cplusplus`宏，而g++会
  * 实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释
  * 如上所述，如果后缀为.c，并采用gcc编译器，则该宏就是未定义的，否则，就是已定义的。
* **误区三：**编译只能为gcc，链接只能用g++
  * 严格来说，这句话不算错误，但它混淆了概念，应该这样说：编译可以用`gcc/g++`，而链接可以用`g++`或`gcc -lstdc++`
  * gcc命令不能自动和C++程序使用的库链接，所以通常使用g++来完成链接。但在编译阶段，g++会自动调用gcc，二者等价

### 04/GCC编译常用参数

|gcc编译选项|说明|
|:----:|:----:|
|-E|预处理指定的源文件，不进行编译|
|-S|编译指定的源文件，但是不进行汇编|
|-c|编译、汇编指定的源文件，但是不进行链接|
|-o|将文件编译成可执行文件|
|-I directory|指定include包含文件的搜索目录|
|-g|在编译的时候，生成调试信息，该程序可以被调试器调试|
|-D|在程序编译的时候，指定一个宏---相当于define，**用于进行调试**|
|-w|不生成任何警告信息|
|-wall|生成警告信息|
|-On|n的取值范围：0~3，编译器的优化选项的4个级别；-o0表示没有优化，-o1为缺省值，-o3优化级别最高**防止反汇编**|
|-l|在程序编译时，指定使用的库|
|-L|指定编译时，搜索库的路径|
|-fPIC/-fpic|生成与位置无关的代码|
|-shared|生成共享目标文件，通常用在建立共享库时|
|-std|指定C方言，如：-std=c99，gcc默认的方言是GNU C|

## 三、静态库和动态库

### 01/什么是库

* 库文件是计算机上的一类文件，可以简单的把库文件看成一种**代码仓库**，它提供给使用者一些可以拿来用的变量、函数或类
* 库是特殊的一种程序，编写库的程序和编写一般的程序区别不大，只是**库不能单独运行**。
* **静态库和动态库（共享库）的区别：**静态库在程序的链接阶段被复制到了程序中；动态库在*链接阶段*没有被复制到程序中，而是程序在运行时有系统*动态加载*到内存中供程序调用
* **库的好处：**1.代码保密；2.方便部署和分发

### 02/静态库的制作

* 命名规则：
  >***Linux***: libxxx.a  
  >>lib: 前缀（固定）  
  >>xxx: 库的名字，自己起  
  >>.a: 后缀（固定）  
  >
  >***Windows***: libxxx.lib

* 静态库的制作：
  1. gcc获得.o文件
  2. 将.o文件打包，使用`ar`工具`archive`

  `ar rcs libxxx.a xxx.o xxx.o`
    > r - 将文件插入备存文件中  
    > c - 建立备存文件  
    > s - 索引  
  
* 静态库的使用

```shell
gcc main.c -o app -I 头文件目录 -l 库的名称 -L 库的位置
```

### 03/动态库（共享库）的制作

* 命名规则：
  > ***Linux***: libxxx.so--在Linux下是个可执行文件
  >>lib: 前缀（固定）  
  >>xxx: 库的名字，自己起  
  >>.so: 后缀（固定）  
  >***Windows***: libxxx.dll

* 动态库的制作：
  1. gcc得到.o文件，得到和位置无关的代码`gcc -c -fpic/-FPIC a.c b.c`
  2. gcc得到动态库`gcc -shared a.o b.o -o libcalc.so`

* 动态库的使用：

```shell
gcc main.c -o main -I include/ -L 动态库路径 -l calc
```

* 动态库加载失败的原因：（工作原理）
  * 静态库：GCC进行链接时，会把静态库中代码打包到可执行程序中
  * 动态库：GCC进行链接时，动态库的代码不会被打包到可执行程序中
  * 程序启动之后，动态库会被动态加载到内存中，通过`ldd 可执行程序`（list dynamic dependencies）命令检查动态库依赖关系
  * 如何定位共享文件呢？
    > 当系统加载可执行代码时，能够知道其所依赖的库的名字，但还需要知道绝对路径。此时就需要系统的**动态载入器**来获取该**绝对路径**。对于elf格式的可执行程序，是有ld-linux.so来完成的，它先后搜索elf文件的**DT_RPATH段**-->**环境变量LD_LIBRARY_PATH**-->**/etc/ld.so.cache文件列表**-->**/lib/,/usr/lib**目录找到库文件后将其载入内存
